---
layout: "../../layouts/BlogPost.astro"
title: "Learning 31 programming languages in 31 days with Advent of Code"
pubDate: "2022-12-01"
updatedDate: "2022-12-17"
description: "Instead of just using a single language, I wanted to solve the puzzle in a language I know, then lurk the internet for the solution in another language each day."
tags: ["Code"]
---

_This post is still a work in progress, please excuse the incompleteness._

The excitement of waking up every morning with a new puzzle to solve is one of the many reasons I love December. I've never actually completed [Advent of Code](https://adventofcode.com), a daily advent calendar-style programming challenge created by [@ericwastl](https://twitter.com/ericwastl), but I think this is my year.

I've made attempts in the past, but usually gave up because it was too hard, or I didn't have time to go all the way through 31 different challenges. But this year, I figured out a way to make it easier, and I decided to learn 31 new programming languages in the process.

Jump to day:

* [Day 1 - Javascript](#day-1-javascript)
* [Day 2 - Rust](#day-2-rust)
* [Day 3 - Crystal](#day-3-crystal)
* [Day 4 - Elm](#day-4-elm)
* [Day 5 - Java](#day-5-java)
* [Day 6 - Excel](#day-6-excel)
* [Day 7 - Python](#day-7-python)
* [Day 8 - Deno](#day-8-deno)
* [Day 9 - jq](#day-9-jq)
* [Day 10 - Clojure](#day-10-clojure)
* [Day 11 - Dart](#day-11-dart)
* [Day 12 - Smalltalk](#day-12-smalltalk)
* [Day 13 - nim](#day-13-nim)
* [Day 14 - C#](#day-14-c)
* [Day 15 - C++](#day-15-c)
* [Day 16 - C3](#day-16-c3)

## [Day 1](https://adventofcode.com/2022/day/1): Javascript

My original plan was to complete all of the challenges in Golang first, and then I was going to attempt to learn Rust and do each challenge in Rust. This turned out to be a lot more work than I thought; it took significantly more code to solve the challenges in Golang & Rust and I wanted to have success faster.

I needed to start with a language that I felt comfortable with and had a lot of experience with. Enter our trusty, old friend from long ago: Javascript.

I started the challenge a few days late (December 3rd), so I wanted to lurk on Github and see how others were solving the puzzles. Some would call this cheating; I call it learning. I had an ephiphany when I was saw how simple [@colourgarden's JS solution for Day 1](https://github.com/colourgarden/advent-of-code/blob/main/2022/day1/index.js) was:

```js
const path = require('path');
const fs = require('fs');

// Get input data of groups of numbers separated by blank lines.
const data = fs.readFileSync(`./input.txt`, 'utf-8');

// Convert the individual lines of each group to Numbers and tally.
const elves = data.split('\n\n').map(group => {
  return group
    .split('\n')
    .map(group => Number(group))
    .reduce((total, calories) => total + calories);
});

// Find the biggest number in the resultant array.
const most = Math.max(...elves);

// Get the index of the biggest number.
const who = elves.indexOf(most);

// Print answer to part one.
console.log(`Elf ${who} is carrying the most calories. They are carrying ${most} calories.`);
```

This code is concise, well-commented, and super easy to understand. I ran it locally with `node 01/main.js` and got the answer for part 1. Their solution for part 2 was just as simple:

```js
// Sort values by descending.
const sorted = [...elves].sort((a, b) => b - a);

// Get three biggest numbers and tally.
const topThree = sorted.slice(0, 3).reduce((total, calories) => total + calories);

// Print answer to part two.
console.log(topThree);
```

I peeked at their solution for day 2 and did the same thing. He hadn't started the challenge for day 3 yet but I was determined to solve it. With a little help from [Github Copilot](https://github.com/features/copilot), I was able to solve day 3 in just a few minutes.

**I had my new plan: each day, complete all of the challenges in Javascript first, then try to complete the challenge in a new language I'm not familiar with.**

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/01/js/main.js)_

## [Day 2](https://adventofcode.com/2022/day/2): Rust

Whenever I learn a new language, I immediately visit https://learnxinyminutes.com. I love this site because it gives you a quick overview of the syntax of a language, with tons of comments and example code. I skimmed the Rust page there and also discovered this useful, step-by-step resource for [getting started with Rust](https://stepik.org/lesson/9268/step/1).

One of the challenges of learning all these new languages is that I'll have to install the build tools locally and get familiar with the developer experience.

Luckily, installing Rust & Cargo (Rust's package manager) is a one-liner:

```sh
curl https://sh.rustup.rs -sSf | sh
```

When I initially attempted the challenge in Rust, I set out to find some solutions from skilled Rust developers on Github. Luckily, I found [this awesome repo](https://github.com/Bogdanp/awesome-advent-of-code) with AOC solutions in many languages (wow, someone did it in [Excel](https://github.com/askholme/advent-of-code)). I jumped to the Rust section and tried to find a good example. 

I discovered ZAZPRO's [AOC repo](https://github.com/ZAZPRO/adventofcode-2022) and noticed a `00` folder with a Hello World script. I cloned the repo, and ran it locally with `cargo run --bin part_one`:

```sh
➜ cargo run --bin part_one
   Compiling rust v0.1.0 (/Users/mager/Code/adventofcode-2022/00/rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.90s
     Running `target/debug/part_one`
Hello, world!
```

Easy enough. Next, I wanted to copy their solution locally and try to run it. In my `02` folder, I ran `cargo new rust` which created a few new files:

```sh
├── Cargo.toml
└── src
    └── main.rs
```

I followed @ZAZPRO's lead and created a `bin` folder in `src` and added the code to `part_one.rs` and ran it locally:

```sh
➜ cargo run --bin part_one
   Compiling rust v0.1.0 (/Users/mager/Code/aoc/2022/02/rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.82s
     Running `target/debug/part_one`
Final Score: 8392
```

It works! Now, let's check out the solution for part 1 in Rust:

```rs
use std::error::Error;

// Enum that describes match result.
enum Outcome {
    Win,
    Draw,
    Lose,
}

// Trait for outcome to calculate result score.
impl Outcome {
    pub fn get_score(&self) -> u32 {
        match &self {
            Outcome::Win => 6,
            Outcome::Draw => 3,
            Outcome::Lose => 0,
        }
    }
}

// Possible Items that players can throw.
enum Item {
    Rock,
    Paper,
    Scissors,
}

// Value of each Item.
impl Item {
    pub fn get_score(&self) -> u32 {
        match &self {
            Item::Rock => 1,
            Item::Paper => 2,
            Item::Scissors => 3,
        }
    }
}

// Struct that holds each game Round.
struct Round {
    opponent: Item,
    player: Item,
}

impl Round {
    // Common Rust way to create structs.
    pub fn new(opponent: Item, player: Item) -> Self {
        Self { opponent, player }
    }

    // Calculate outcome of the Round.
    pub fn get_outcome(&self) -> Outcome {
        match (&self.player, &self.opponent) {
            (Item::Rock, Item::Scissors) => Outcome::Win,
            (Item::Rock, Item::Paper) => Outcome::Lose,
            (Item::Paper, Item::Rock) => Outcome::Win,
            (Item::Paper, Item::Scissors) => Outcome::Lose,
            (Item::Scissors, Item::Paper) => Outcome::Win,
            (Item::Scissors, Item::Rock) => Outcome::Lose,
            _ => Outcome::Draw,
        }
    }

    // Calculate score of the round.
    pub fn calc_score(&self) -> u32 {
        &self.player.get_score() + &self.get_outcome().get_score()
    }
}

// Program entry point.
fn main() -> Result<(), Box<dyn Error>> {
    // List of game rounds.
    let mut rounds: Vec<Round> = Vec::new();

    // Read input file into String.
    let file = std::fs::read_to_string("../input.txt")?;
    // For each line in the file.
    for line in file.lines() {
        // Split a line in two values.
        let mut iter = line.split_whitespace();

        // First value is what current opponent is throwing.
        let current_opponent = match iter.next() {
            Some(v) => match v {
                "A" => Item::Rock,
                "B" => Item::Paper,
                "C" => Item::Scissors,
                _ => todo!(),
            },
            None => todo!(),
        };

        // Second value is what current player is throwing.
        let current_player = match iter.next() {
            Some(v) => match v {
                "X" => Item::Rock,
                "Y" => Item::Paper,
                "Z" => Item::Scissors,
                _ => todo!(),
            },
            None => todo!(),
        };

        // Create a new Round struct with opponent and player values.
        rounds.push(Round::new(current_opponent, current_player));
    }

    // Calculate a final sum by calling a score calculation method of Round struct and summing those up.
    let final_sum: u32 = rounds.into_iter().map(|r| r.calc_score()).sum();
    println!("Final Score: {final_sum}");

    Ok(())
}
```

It's a lot of code, but it makes sense. At first glance it reminds me of Ruby or Elixir, but more elegant. I'd like to play around more with Rust, but there's no time; I need to learn another new language.

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/02/js/main.js)_

## [Day 3](https://adventofcode.com/2022/day/3): Crystal

I heard about this one briefly on Hacker News a while back and always wanted to use it. While `brew install crystal` ran, I determined that Crystal is like a mix between Ruby and C. From their [Github README](https://github.com/crystal-lang/crystal):

> We love Ruby's efficiency for writing code. We love C's efficiency for running code. We want the best of both worlds.

Let's take a look at the solution for day 1 before we try to run it:

```rb
puts STDIN.each_line.reduce(0) { |acc, line|
  s = line.size() // 2
  a,b = line[0..s-1],line[s..]
  common = (a.chars.to_set & b.chars.to_set).to_a[0]
  priority = common.ord - (common.uppercase? ? 38 : 'a'.ord - 1)
  acc + priority
}
```

I love how simple this is, way less code than my JS implementation. Shoutout to [@DestyNova](https://github.com/DestyNova/advent_of_code_2022/tree/main/3) on the solution & detailed blog post about the experience (and how he used ChatGPT to find a solution in Python).

Getting this running locally was pretty easy as well:

```sh
➜  crystal git:(main) ✗ cat ../input.txt | crystal run part1.cr
... Lots of "ld: warning: object file (somefile.o) was built for newer macOS version than being linked" warnings ...
7785
```

Here's part 2:

```rb
puts STDIN.each_line.to_a.in_groups_of(3, "").reduce(0) { |acc,lines|
  common = lines.map {|s| s.chars.to_set}.reduce {|a,s| a & s}.to_a[0]
  priority = common.ord - (common.uppercase? ? 38 : 'a'.ord - 1)
  acc + priority
}
```

Crystal looks fun and I want to spend more time with it. Fun fact: The last time I worked on anything that resembled Ruby was one of my first hack day projects (almost 10 years ago!): [Sendwiki](https://github.com/mager/sendwiki/blob/master/main.rb).

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/03/js/main.js)_

## [Day 4](https://adventofcode.com/2022/day/4): Elm

I've seen Elm before on Hacker News, but never double clicked further. A quick glance at [Learn X](https://learnxinyminutes.com/docs/elm/), and the syntax looks... pretty? No brackets, pipe functions, indenting matters, support for pattern matching. I approve. It only took a few seconds to install, and they even suggested a [tutorial](https://guide.elm-lang.org/) to get started.

Let's check out [@ostcar](https://github.com/ostcar/aoc2022)'s solution:

```elm
module Days.Day4 exposing (solution, testSolution1, testSolution2)

import Expect exposing (equal)
import Parser exposing ((|.), (|=), int, symbol)
import Test exposing (Test, test)


solution : ( () -> String, () -> String )
solution =
    ( \_ -> solution1 puzzleInput
    , \_ -> solution2 puzzleInput
    )


solution1 : String -> String
solution1 =
    String.lines
        >> List.filter (String.isEmpty >> not)
        >> List.map parseLine
        >> countFunc isFullIntersect
        >> String.fromInt


parseLine : String -> ( ( Int, Int ), ( Int, Int ) )
parseLine input =
    let
        inputParser =
            Parser.succeed (\a b c d -> ( ( a, b ), ( c, d ) ))
                |= int
                |. symbol "-"
                |= int
                |. symbol ","
                |= int
                |. symbol "-"
                |= int
    in
    Parser.run inputParser input
        |> Result.withDefault ( ( 0, 0 ), ( 0, 0 ) )


isFullIntersect : ( ( Int, Int ), ( Int, Int ) ) -> Bool
isFullIntersect ( first, second ) =
    let
        firstIsFullIntersect ( a, b ) ( c, d ) =
            a >= c && b <= d
    in
    firstIsFullIntersect first second || firstIsFullIntersect second first


countFunc : (a -> Bool) -> List a -> Int
countFunc func list =
    List.foldl
        (\e count ->
            if func e then
                count + 1

            else
                count
        )
        0
        list


testSolution1 : Test
testSolution1 =
    test "test input1" <|
        \_ -> equal (solution1 testInput) "2"


solution2 : String -> String
solution2 =
    String.lines
        >> List.filter (String.isEmpty >> not)
        >> List.map parseLine
        >> countFunc isPartlyIntersect
        >> String.fromInt


isPartlyIntersect : ( ( Int, Int ), ( Int, Int ) ) -> Bool
isPartlyIntersect ( first, second ) =
    let
        firstInSecond ( a, b ) ( c, d ) =
            a <= c && b >= c
    in
    firstInSecond first second || firstInSecond second first


testSolution2 : Test
testSolution2 =
    test "test input2" <|
        \_ -> equal (solution2 testInput) "4"


testInput : String
testInput =
    """
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8"""


puzzleInput : String
puzzleInput =
    """
75-76,18-75
2-54,1-50
82-83,78-82
...
"""
```

Definitely some weird syntax going on in there, but the code is readable and it makes sense. I was surpsied you could import these parser operators like `|.` and `|=` (great docs on the [Parser](https://package.elm-lang.org/packages/elm/parser/latest/) by the way).

I was really curious to get this up and running, and it turns out that @ostcar built a website along with the code. 

```
➜  elm make src/Main.elm
Starting downloads...
Dependencies ready!
Success! Compiled 8 modules.

    Main ───> index.html
```

The web page shows a list of days and a link to their solution. Here's the [source](https://github.com/ostcar/aoc2022/blob/main/src/Main.elm) if you're interested.

Elm looks pretty powerful. I also starred [this repo from @rtfeldman](https://github.com/rtfeldman/elm-spa-example) for later to learn how to build a single page application using Elm.

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/04/js/main.js)_

## [Day 5](https://adventofcode.com/2022/day/5): Java

While I haven't actually built anything myself in Java, I've been familiar with it for a while and been exposed to it in code reviews and interviews a bunch. I hope to play with Kotlin before Xmas.

I found an elegant solution (with tests!) from [@vuryss](https://github.com/vuryss/aoc-java/blob/master/src/main/java/com/vuryss/aoc/solutions/event2022/Day5.java):

```java
package com.vuryss.aoc.solutions.event2022;

import com.vuryss.aoc.DayInterface;

import java.util.*;

public class Day5 implements DayInterface {
    @Override
    public Map<String, String> part1Tests() {
        return Map.of(
            """
                [D]    
            [N] [C]    
            [Z] [M] [P]
             1   2   3
            
            move 1 from 2 to 1
            move 3 from 1 to 3
            move 2 from 2 to 1
            move 1 from 1 to 2
            """,
            "CMZ"
        );
    }

    @Override
    public Map<String, String> part2Tests() {
        return Map.of(
            """
                [D]    
            [N] [C]    
            [Z] [M] [P]
             1   2   3
            
            move 1 from 2 to 1
            move 3 from 1 to 3
            move 2 from 2 to 1
            move 1 from 1 to 2
            """,
            "MCD"
        );
    }

    @Override
    public String part1Solution(String input) {
        var parts = input.split("\n\n");
        var stacks = createCurrentState(parts[0]);

        for (var line: parts[1].split("\n")) {
            var moveParts = line.trim().split(" ");
            var originStack = stacks.get(Integer.parseInt(moveParts[3]));
            var targetStack = stacks.get(Integer.parseInt(moveParts[5]));

            for (var i = 0; i < Integer.parseInt(moveParts[1]); i++) {
                targetStack.addFirst(originStack.pollFirst());
            }
        }

        return getTopCrates(stacks);
    }

    @Override
    public String part2Solution(String input) {
        var parts = input.split("\n\n");
        var stacks = createCurrentState(parts[0]);

        for (var line: parts[1].split("\n")) {
            var moveParts = line.trim().split(" ");
            var originStack = stacks.get(Integer.parseInt(moveParts[3]));
            var targetStack = stacks.get(Integer.parseInt(moveParts[5]));
            var tempList = new LinkedList<Character>();

            for (var i = 0; i < Integer.parseInt(moveParts[1]); i++) {
                tempList.add(originStack.pollFirst());
            }

            while (!tempList.isEmpty()) {
                targetStack.addFirst(tempList.pollLast());
            }
        }

        return getTopCrates(stacks);
    }

    private HashMap<Integer, LinkedList<Character>> createCurrentState(String state) {
        var stacks = new HashMap<Integer, LinkedList<Character>>();

        for (var line: state.split("\n")) {
            var charIndex = 1;
            var stackId = 1;

            while (line.length() > charIndex) {
                var c = line.charAt(charIndex);
                var stack = stacks.getOrDefault(stackId, new LinkedList<>());
                stacks.putIfAbsent(stackId, stack);

                if (c >= 'A' && c <= 'Z') {
                    stack.add(c);
                }

                charIndex += 4;
                stackId++;
            }
        }

        return stacks;
    }

    private String getTopCrates(HashMap<Integer, LinkedList<Character>> stacks) {
        StringBuilder result = new StringBuilder();

        for (var entry: stacks.entrySet()) {
            result.append(entry.getValue().peek());
        }

        return result.toString();
    }
}
```

This puzzle was trickier because you had to do more work to parse the input:

```
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 
```

We have to strip out the spaces and `[]` characters and rotate it so we can work with the stacks better. We need something like: `[[Z, N], [M, C, D], [P]]`.

In Javascript, we can use a helper transpose function and pipe some map and filter functions:


```js
Array.prototype.transpose = function () {
    return this[0].map((_, i) => this.map((y) => y[i]));
};

const stacks = input_stacks
    .map((row) => [...row])
    .transpose()
    .map((row) => row.join("").replace(/\[|\]/g, "").trim())
    .filter((row) => row !== "")
    .map((row) => [...row.slice(0, -1)].reverse());
```

In Java, we iterate through each character and check if it's a letter and add it to a `LinkedList`:

```java
private HashMap<Integer, LinkedList<Character>> createCurrentState(String state) {
    var stacks = new HashMap<Integer, LinkedList<Character>>();

    for (var line: state.split("\n")) {
        var charIndex = 1;
        var stackId = 1;

        while (line.length() > charIndex) {
            var c = line.charAt(charIndex);
            var stack = stacks.getOrDefault(stackId, new LinkedList<>());
            stacks.putIfAbsent(stackId, stack);

            if (c >= 'A' && c <= 'Z') {
                stack.add(c);
            }

            charIndex += 4;
            stackId++;
        }
    }

    return stacks;
}
```

The docs for [HashMap](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html) are detailed, and function names like `getOrDefault` and `putIfAbsent` are clear and intuitive.

Let's see how easy it is to get running locally. One reason I chose `@vuryss`'s solution is because his README had instructions on how to run it and included a straightforward command for running a specific day's solution: `./gradlew bootRun --args="--day=1"`.

It's as easy as running `brew install java` to get Java installed these days (previously you had to download an executable and install the JVM separately). While I waited, I asked [ChatGPT](https://chat.openai.com/chat) why Java is so popular:

![Java is a popular programming language because it is versatile and easy to learn. It is widely used for building a variety of applications, including web, mobile, and desktop applications. Additionally, Java has a large and active community of developers, which makes it easy to find support and assistance when needed. Because of its popularity, there is a wealth of documentation and learning resources available, making it a good choice for people who are new to programming.](/images/blog/2022-12-01-aoc.md/day-5-1.png)

So, I actually had trouble running this locally, but I'll circle back later and try again when I have more time.

I'm a few days behind so, on to the next one!

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/05/js/main.js)_

## [Day 6](https://adventofcode.com/2022/day/6): Excel

That's right, you didn't misread. We're going to solve this one with Excel. While Microsoft's spreadsheet app isn't technically considered a programming language, it's been used for decades for manipulating data, and its table-first, dependable interface seems like a perfect tool for this challenge. In fact, the underlying programming language that is used in that little input box above the table is [VBA](https://learn.microsoft.com/en-us/office/vba/api/overview/language-reference), which is a dialect of Visual Basic.

Luckily someone was brave enough to try these challenges in Excel ([shoutout @askholme](https://github.com/askholme/advent-of-code/blob/main/2022/Day%206.xlsx)). I downloaded the `xlsx` file and uploaded it to Google Drive.

![AOC Day 6 using spreadsheets](/images/blog/2022-12-01-aoc.md/day-6-1.png)

In cell A1, we have the 4000 plus-character string. And then in each row below, we grab a 14-character chunk using the [MID function](https://support.google.com/docs/answer/3094129?hl=en) which lets you select a substring given a starting point and character length. Columns C-P is a single character, and then in column Q, we're using a combination of COUNTA and UNIQUE to determine if the first four characters are all unique. So the first row looks like this:

```
=COUNTA(UNIQUE(C4:F4,1,TRUE))=4
```

Then you can filter for TRUE and the first row returned is the answer. 

![AOC Day 6 using spreadsheets](/images/blog/2022-12-01-aoc.md/day-6-2.png)

Column R is the same thing for part 2 (14 characters instead of 4). Pretty clever, I must say. I'm going to lurk on this repo to see how other days are solved.

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/06/js/main.js)_

## [Day 7](https://adventofcode.com/2022/day/7): Python

The challenges are getting tougher. Today, we are told that our computer is out of space, and are given a list of input that shows someone navigating around directories running `ls` to see which directories have large files in them:

```
$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
...
```

We have to determine the directory structure from the above input, and then sum up the largest files to determine which ones to delete.

After spending a few minutes grokking the excellent solution from @colourgarden, I decided to try check the public leaderboard to see how the all-stars are doing it.

I picked a random user in the top 10 and it was @jonathanpaulson, and [the solution was written in Python](https://github.com/jonathanpaulson/AdventOfCode/blob/master/2022/7.py); a language I'm very familiar with from my days of hacking Django at Postmates.

```py
#!/usr/bin/python3
import sys
from collections import defaultdict
infile = sys.argv[1] if len(sys.argv)>1 else '7.in'
data = open(infile).read().strip()
lines = [x for x in data.split('\n')]

# directory path -> total size of that directory (including subdirectories)
SZ = defaultdict(int)
path = []
for line in lines:
    words = line.strip().split()
    if words[1] == 'cd':
        if words[2] == '..':
            path.pop()
        else:
            path.append(words[2])
    elif words[1] == 'ls':
        continue
    elif words[0] == 'dir':
        continue
    else:
        sz = int(words[0])
        # Add this file's size to the current directory size *and* the size of all parents
        for i in range(1, len(path)+1):
            SZ['/'.join(path[:i])] += sz

max_used = 70000000 - 30000000
total_used = SZ['/']
need_to_free = total_used - max_used

p1 = 0
p2 = 1e9
for k,v in SZ.items():
    #print(k,v)
    if v <= 100000:
        p1 += v
    if v>=need_to_free:
        p2 = min(p2, v)
print(p1)
print(p2)
```

This is pretty clean; it uses a [defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict) to keep track of the size of each directory (key = dir name, value = size).

```py
defaultdict(<class 'int'>, {
    '/': 44376732,
    '//lhrfs': 240152,
    '//nwh': 834387,
    '//nwh/pmdj': 514336,
    '//pjsd': 22040913,
    '//pjsd/czzcslm': 266197,
    '//pjsd/dgwpl': 492311,
    '//pjsd/dgwpl/ljzrwpv': 468764,
    // ...
})
```

Then you can just loop through and tally up the total size of each directory, and then find the largest files that needs to be deleted.

I'm definitely going to check back in on how `@jonathanpaulson` is doing throughout the month.

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/07/js/main.js)_

## [Day 8](https://adventofcode.com/2022/day/8): Deno

Today's puzzle input is a huge grid of numbers that represents tree heights in a forest. And we have to determine which trees are visibile when looking from any angle (part 1), and then we have to give each tree a "scenic score" to find the tree with area with the best view for building a treehouse (part 2).

![Tree grid screenshot](/images/blog/2022-12-01-aoc.md/day-8-1.png)

[Deno](https://deno.land/) is a Javascript runtime environment, similar to Node.js, but there are a few key differences:

* Deno uses Typescript by default
* There is no package manager, instead you import modules via URLs
* No callbacks, use async/await instead
* Built-in testing framework

I was really impressed with the Deno [getting started guide](https://deno.land/manual@v1.28.3/getting_started/first_steps), which walks you from Hello, World to creating a web server that returns an API response from Github.

Let's checkout the incredible solution for Day 8 from [@ismtabo](https://github.com/ismtabo/advent-of-code-2022):

```ts
function preprocess(text: string) {
  return text.trim().split("\n").map((line) =>
    Array.from(line.trim()).map((char) => parseInt(char))
  );
}

function partOne(input: number[][]) {
  return input.flat().filter((height, position) => {
    const x = Math.floor(position % input[0].length);
    const y = Math.floor(position / input[0].length);
    return input.at(y)!.slice(0, x).every((other) => other < height) ||
      input.at(y)!.slice(x + 1).every((other) => other < height) ||
      input.slice(0, y).every((row) => row.at(x)! < height) ||
      input.slice(y + 1).every((row) => row.at(x)! < height);
  }).length;
}


function lookUp(y: number, input: number[][], x: number, height: number) {
  if (y === 0) {
    return 1;
  }
  let closesTaller = input.slice(0, y).reverse().findIndex((row) =>
    row.at(x)! >= height
  );
  if (closesTaller === -1) {
    closesTaller = y - 1;
  }
  return closesTaller + 1;
}

function lookLeft(x: number, y: number, input: number[][], height: number) {
  if (x === 0) {
    return 1;
  }
  let closestTaller = input.at(y)!.slice(0, x).reverse().findIndex((other) =>
    other >= height
  );
  if (closestTaller === -1) {
    closestTaller = x - 1;
  }
  return closestTaller + 1;
}

function lookRight(x: number, input: number[][], y: number, height: number) {
  if (x === input[0].length - 1) {
    return 1;
  }
  let closestTaller = input.at(y)!.slice(x + 1).findIndex((other) =>
    other >= height
  );
  if (closestTaller === -1) {
    closestTaller = input[0].length - x - 2;
  }
  return closestTaller + 1;
}

function lookDown(y: number, input: number[][], x: number, height: number) {
  if (y === input.length - 1) {
    return 1;
  }
  let closesTaller = input.slice(y + 1).findIndex((row) =>
    row.at(x)! >= height
  );
  if (closesTaller === -1) {
    closesTaller = input.length - y - 2;
  }
  return closesTaller + 1;
}

function partTwo(input: number[][]) {
  const values = input.flat().map((height, position) => {
    const x = Math.floor(position % input[0].length);
    const y = Math.floor(position / input[0].length);
    if (
      x === 0 || x === input[0].length - 1 || y === 0 || y === input.length - 1
    ) {
      return -Infinity;
    }
    const up = lookUp(y, input, x, height);
    const left = lookLeft(x, y, input, height);
    const right = lookRight(x, input, y, height);
    const down = lookDown(y, input, x, height);
    const visibility = left * right * up * down;
    return visibility;
  });
  return Math.max(...values);
}

export function main(text: string) {
  const input = preprocess(text);

  console.log(partOne(input));
  console.log(partTwo(input));
}
```

The docs from the README were great, and the author created a very nice (and modular) cli for running the code:

```sh
➜ deno run -A --unstable src/cli/mod.ts run -d 8 -p 1
1798
➜ deno run -A --unstable src/cli/mod.ts run -d 8 -p 2
259308
```

Additionally, there was an amazing 8-bit style website that accompanied the code, which let you paste your input and validate the expected result.

![Deno 8-bit website](/images/blog/2022-12-01-aoc.md/day-8-2.png)

![Deno 8-bit website](/images/blog/2022-12-01-aoc.md/day-8-3.png)

Here's another useful resource for [Deno examples](https://examples.deno.land/) if you're interested in learning more.

Let's keep moving...

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/08/js/main.js)_

## [Day 9](https://adventofcode.com/2022/day/9): jq

The puzzle today is all about tracing a path on a grid, and the input is a list of instructions like: `L 4, U 2, R 1, D 3`, which means "go left 4, up 2, right 1, down 3". In part 1, we need to follow the tail and count how many cells it's been to. In part 2, the tail is 10 units long, so it will touch more cells.

[jq](https://stedolan.github.io/jq/) is a usually meant to process JSON but it can handle any kind of input. Let's check out the [solutions from @christianberg](https://github.com/christianberg/advent/tree/main/2022/09).

Part 1:

```sh
#!/usr/bin/env jq -rRsf
split("\n")[:-1] |
map(split(" ") | .[0]*(.[1]|tonumber)) |
join("") | split("") |
map(
  {"R": [1,0], "L": [-1,0], "U": [0,1], "D": [0,-1]}[.]
) |
[foreach .[] as $step ([0,0]; [.[0]+$step[0],.[1]+$step[1]]; .)] |
[foreach .[] as $head (
  [0,0];
  if (.[0]-$head[0])>1 or (.[0]-$head[0])<-1 or (.[1]-$head[1])>1 or (.[1]-$head[1])<-1 then
    .[0] |= . + ([([($head[0]-.),1] | min),-1] | max) |
    .[1] |= . + ([([($head[1]-.),1] | min),-1] | max) 
  else
    .
  end;
  .
)] |
unique | length
```

Part 2:

```sh
#!/usr/bin/env jq -rRsf
split("\n")[:-1] |
map(split(" ") | .[0]*(.[1]|tonumber)) |
join("") | split("") |
map(
  {"R": [1,0], "L": [-1,0], "U": [0,1], "D": [0,-1]}[.]
) |
[foreach .[] as $step ([0,0]; [.[0]+$step[0],.[1]+$step[1]]; .)] |
reduce range(9) as $_ (.;
[foreach .[] as $head (
  [0,0];
  if (.[0]-$head[0])>1 or (.[0]-$head[0])<-1 or (.[1]-$head[1])>1 or (.[1]-$head[1])<-1 then
    .[0] |= . + ([([($head[0]-.),1] | min),-1] | max) |
    .[1] |= . + ([([($head[1]-.),1] | min),-1] | max) 
  else
    .
  end;
  .
)]) |
unique | length
```

You can run these but using cat and piping the input to the script:

```sh
➜  cat input.txt | part1.jq
6366
➜  cat input.txt | part2.jq
2601
```

If you want to understand it line by line, you can step through each line the command line:

```sh
➜ cat input.txt | jq -rRs 'split("\n")[:-1] | map(split(" ") | .[0]*(.[1]|tonumber)) | join("") | split("")'
[
  "L",
  "U",
  "U",
  "L",
  "U",
  "U",
  "L",
  "L",
  "R",
  "L",
  "U",
  ...
]
```

Another tool for visualizing jq results is [jqplay.org](https://jqplay.org/):

![Day 9 debugging with jqplay.org](/images/blog/2022-12-01-aoc.md/day-9-1.png)

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/09/js/main.js)_

## [Day 10](https://adventofcode.com/2022/day/10): Clojure

Clojure is a dialect of Lisp built on the JVM. A quick glance at [Learn X in Y Minutes](https://learnxinyminutes.com/docs/clojure/) and you'll see how simple and minimal the language is.

Sure enough, someone has a similarly minimal solution for today's puzzle, which requires us to construct a cathode ray tube (CRT) from a list of instructions.

I found an awesome solution from [@coutego](https://github.com/coutego/advent-of-code-2022/blob/main/src/aoc22.clj):

```clojure

;; Day 10
(defn exec [state [op arg]]
  (let [[[_ _ x] cycle] (or (last state) [[1 1 1] 0])]
    (cond
      (= op "noop") (conj state [[x x x] (inc cycle) "noop"])
      (= op "addx") (-> state
                        (conj [[x x x] (inc cycle)])
                        (conj [[x x (+ x arg)] (+ 2 cycle)])))))

(defn sum-idxs [sts]
  (let [f (fn [sts id] (* id (->> id (nth sts) first second)))]
    (+ (f sts 20)
       (f sts 60)
       (f sts 100)
       (f sts 140)
       (f sts 180)
       (f sts 220))))

(defn sprite-in-draw-position? [idx cycle]
  (let [col (mod idx 40)
        pos (-> cycle first second)]
    (< (abs (- pos col)) 2)))

(defn parse-d10 [s]
  (let [[op arg] (st/split s #" ")]
    [op (and arg (parse-int arg))]))

(defn d10p1 [& [filename]]
  (->> (read-input-day (or filename "d10") parse-d10)
       (reduce exec [[[1 1 1] 0]])
       sum-idxs))

(defn d10p2 [& [filename]]
  (->> (read-input-day (or filename "d10") parse-d10)
       (reduce exec [[[1 1 1] 0]])
       (drop 1)
       (map-indexed sprite-in-draw-position?)
       (map (fn [b] (if b "#" " ")))
       (partition 40)
       (map (fn [ss] (apply str ss)))))

(deftest d10
  (is (= (d10p1 "d10-test") 13140))
  (is (= (d10p1) 17380))
  (is (= (-> (d10p2) first (nth 5)) \space))
  (is (= (-> (d10p2) second (nth 2)) \space))
  (is (= (-> (d10p2) second (nth 5)) \#)))
```

I checked out the docs for [`map-indexed`](https://clojuredocs.org/clojure.core/map-indexed) and [`partition`](https://clojuredocs.org/clojure.core/partition) and was impressed that the community can share examples in the official docs. These were really helpful!

After a few tries, I was able to use `lein` to run tests locally in @coutego's repo.

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/10/js/main.js)_

## [Day 11](https://adventofcode.com/2022/day/11): Dart

The last time I worked with Dart was [Stephen Grider's amazing Dart and Flutter course on Udemy](https://www.udemy.com/course/dart-and-flutter-the-complete-developers-guide/). (I also really love the [official Flutter channel on YouTube](https://www.youtube.com/@flutterdev)).

Let's check out a [solution from @hieptk](https://github.com/hieptk/aoc22/blob/main/11/main.dart):

```dart
import 'dart:collection';
import 'dart:io';

final bool part1 = false;
final int N_ROUNDS = part1 ? 20 : 10000;
final int mod = 9699690;

class Monkey {
  final Queue<int> items;
  final String op;
  final int opVal;
  final int testVal;
  final int trueThrow, falseThrow;

  Monkey(this.items, this.op, this.opVal, this.testVal, this.trueThrow,
      this.falseThrow);

  void doMonkeyThing(List<Monkey> monkeys) {
    while (items.isNotEmpty) {
      int x = items.removeFirst();
      if (op == '+') {
        x = (x + opVal) % mod;
      } else if (op == '*') {
        x = (x * opVal) % mod;
      } else {
        x = (x * x) % mod;
      }
      if (part1) {
        x ~/= 3;
      }
      if (x % testVal == 0) {
        monkeys[trueThrow].items.addLast(x);
      } else {
        monkeys[falseThrow].items.addLast(x);
      }
    }
  }
}

void main(List<String> arguments) {
  File file = File('input.txt');
  List<String> lines = file.readAsLinesSync();
  List<Monkey> monkeys = [];
  for (int i = 0; i + 5 < lines.length; i += 7) {
    Queue<int> items = Queue.from(lines[i + 1]
        .trimLeft()
        .split(' ')
        .sublist(2)
        .map((e) => int.parse(e.replaceAll(',', ''))));
    List<String> tmp = lines[i + 2].trimLeft().split(' ');
    String op = '';
    int opVal = 1;
    if (tmp.last != 'old') {
      op = tmp[4];
      opVal = int.parse(tmp.last);
    } else {
      // old * old
      op = '^';
      opVal = 2;
    }
    int testVal = int.parse(lines[i + 3].split(' ').last);
    int trueThrow = int.parse(lines[i + 4].split(' ').last);
    int falseThrow = int.parse(lines[i + 5].split(' ').last);
    monkeys.add(Monkey(items, op, opVal, testVal, trueThrow, falseThrow));
  }

  List<int> cnt = List.filled(monkeys.length, 0);
  for (int i = 1; i <= N_ROUNDS; ++i) {
    for (int j = 0; j < monkeys.length; ++j) {
      cnt[j] += monkeys[j].items.length;
      monkeys[j].doMonkeyThing(monkeys);
    }
  }

  print(cnt);
  cnt.sort();
  print(cnt.last * cnt[cnt.length - 2]);
}
```

_[Part 1 Solution in JS](https://github.com/mager/aoc/blob/main/2022/11/js/part1.js) | [Part 2 Solution in JS](https://github.com/mager/aoc/blob/main/2022/11/js/part2.js)_

## [Day 12](https://adventofcode.com/2022/day/12): Smalltalk

I've heard of Smalltalk, but I haven't really been exposed to it much. ChatGPT gives a pretty good summary of what Smalltalk is all about:

> Smalltalk is an object-oriented, dynamically typed programming language that was developed in the 1970s. It was one of the first programming languages to use the concept of "objects" to represent data and methods, and it was also one of the first to use just-in-time compilation. Smalltalk is known for its simplicity and its use of the "programming by messaging" paradigm, which allows objects to communicate with each other by sending and receiving messages. Despite its innovations, Smalltalk has not been widely adopted and is not commonly used today.

When I first read the code, I was impressed how readable it is. One thing I immediately notice: lines end with a period, kinda like a sentence. And comments are surrounded by double quotes. Check out the [Learn X in Y Minutes](https://learnxinyminutes.com/docs/smalltalk/) page for more.

Shoutout to [@musifter on Reddit](https://www.reddit.com/r/adventofcode/comments/zjnruc/comment/izznsd6/?utm_source=reddit&utm_medium=web2x&context=3) for this solution:

```smalltalk
#!/usr/local/bin/gst -q

Collection extend [
    apply: method  [ ^self collect: [:x | x perform: method] ]
]

Object subclass: HeightMap [
    | grid start end |

    dirs := { 0 @ 1. 0 @ -1. 1 @ 0. -1 @ 0 }.

    HeightMap class >> new: arrayStrings [
        ^super new init: arrayStrings
    ]

    init: mapArray [
        | width |
        width := (mapArray at: 1) size + 2.

        grid := OrderedCollection new.
        mapArray keysAndValuesDo: [ :y :line |
            | row x |
            row := line asOrderedCollection apply: #asInteger.
            row addFirst: 128; addLast: 128.    " Add sentinels left/right "

            " Find start "
            (x := row indexOf: $S asInteger) ~= 0 ifTrue: [
                start := x @ (y + 1).
                row at: x put: $a asInteger.
            ].

            " Find end "
            (x := row indexOf: $E asInteger) ~= 0 ifTrue: [
                end := x @ (y + 1).
                row at: x put: $z asInteger.
            ].

            grid add: row asArray.
        ].

        " Add sentinel rows to top and bottom "
        grid addFirst: (Array new: width withAll: 128).
        grid addLast:  (Array new: width withAll: 128).
        ^self
    ]

    at: pt  [ ^(grid at: pt y) at: pt x ]

    start   [ ^start ]
    end     [ ^end   ]

    " Find path from startPos until endBlock is true, with heightAllow rule "
    pathFrom: startPos endWhen: endBlock moving: heightAllow [
        | visit queue state time pos height move |

        " Initialise visit array "
        visit := (1 to: grid size) collect: [ :i |
            Array new: (grid at: 1) size withAll: false
        ].

        " Queue starts with startPos at time 0 "
        queue := OrderedCollection with: { 0. startPos }.

        " Basic BFS loop: "
        [ queue notEmpty ] whileTrue: [
            state := queue removeFirst.
            time  := state first.
            pos   := state second.

            (endBlock value: pos) ifTrue: [ ^time ].

            ((visit at: pos y) at: pos x) ifFalse: [
                (visit at: pos y) at: pos x put: true.

                height := self at: pos.
                dirs do: [ :dir |
                    move := pos + dir.
                    (heightAllow value: height value: (self at: move)) ifTrue: [
                        queue addLast: { time + 1. move }.
                    ]
                ]
            ]
        ]
    ]
]

"
| Mainline
"
map := HeightMap new: stdin lines contents.

" Start to end, going up: "
part1 := map pathFrom: map start
              endWhen: [:pos | pos = map end]
               moving: [:height :targ | (height + 1) >= targ].

('Part 1: %1' % {part1}) displayNl.

" End to level $a, going down: "
part2 := map pathFrom: map end
              endWhen: [:pos | (map at: pos) = $a asInteger]
               moving: [:height :targ | targ between: (height - 1) and: $z asInteger].

('Part 2: %1' % {part2}) displayNl.
```

I didn't actually get this up and running locally. It's not straightforward to setup on a Mac, but I might try it on a Linux machine soon.

_[Part 1 Solution in JS](https://github.com/mager/aoc/blob/main/2022/12/js/part1.js) | [Part 2 Solution in JS](https://github.com/mager/aoc/blob/main/2022/12/js/part2.js)_


## [Day 13](https://adventofcode.com/2022/day/13): nim

I went straight to [Learn X in Y Minutes](https://learnxinyminutes.com/docs/nim/) for this one:

> Nim (formerly Nimrod) is a statically typed, imperative programming language that gives the programmer power without compromises on runtime efficiency. Nim is efficient, expressive, and elegant.

The syntax is very Pythonesque (colons and indents) and looks easy to use. Let's check out a [solution from @MichalMarsalek](https://github.com/MichalMarsalek/Advent-of-code/blob/master/2022/Nim/day13.nim):

```nim
include aoc
import json

day 13:
    func cmp(a, b: JsonNode): int =
        if a.kind == JInt and b.kind == JInt:
            return cmp(a.getInt, b.getInt)
        let aChildren = if a.kind == JArray: a.elems else: @[a]
        let bChildren = if b.kind == JArray: b.elems else: @[b]

        for (a, b) in zip(aChildren, bChildren):
            let c = cmp(a, b)
            if c != 0: return c
        return cmp(aChildren.len, bChildren.len)

    part 1:
        let pairs = input.split("\n\n").mapIt(it.splitLines.mapIt it.parseJson).mapIt (it[0], it[1])
        sum(
            for i, (a, b) in pairs:
                if cmp(a, b) < 0:
                    i+1
        )

    part 2:
        var data = (lines & "[[2]]" & "[[6]]").filterIt(it != "").mapIt it.parseJson
        sort(data, cmp)
        prod:
            collect:
                for i, x in data:
                    if $x in ["[[2]]", "[[6]]"]:
                        i+1
```

Really clean! The [docs](https://nim-lang.org/docs/sequtils.html#mapIt.t%2Ctyped%2Cuntyped) are a joy to read as well. I'll definitely be trying this out another time.

TODO: Run locally.

_[Part 1 Solution in JS](https://github.com/mager/aoc/blob/main/2022/13/js/part1.js) | [Part 2 Solution in JS](https://github.com/mager/aoc/blob/main/2022/13/js/part2.js)_

## [Day 14](https://adventofcode.com/2022/day/14): C#

Today's challenge is tough: you have to calculate sand falling through rock crevices.

I have never used C, C++, or C# but I've always wanted to try it out. I was curious how C# is different than other C variants, so I asked our favorite AI of the moment. The main differences:

* C - Low level, building block for most other languages
* C++ - Statically typed, object oriented, still considered low level
* C# - Modern, object oriented, statically typed, built-in garbage collection
* Objective C - Used mostly for iOS development

Let's check out the [solution from @ShootMe](https://github.com/ShootMe/AdventOfCode/blob/main/Y2022/Puzzle14.cs):

```csharp
using AdventOfCode.Common;
using AdventOfCode.Core;
using System;
using System.Collections.Generic;
using System.ComponentModel;
namespace AdventOfCode.Y2022 {
    [Description("Regolith Reservoir")]
    public class Puzzle14 : ASolver {
        private BlockType[] cave;
        private int width, height, minX, minY;

        public override void Setup() {
            string[] lines = Input.Split('\n');
            List<Line> rockFormations = new();

            minX = int.MaxValue;
            int maxX = int.MinValue;
            minY = 0;
            int maxY = int.MinValue;
            for (int i = 0; i < lines.Length; i++) {
                string line = lines[i];
                string[] points = line.Split(" -> ");

                Line formation = null;
                for (int j = 0; j < points.Length; j++) {
                    string[] point = points[j].Split(',');
                    if (formation == null) {
                        formation = new Line();
                        formation.StartPosition = new Point() { X = point[0].ToInt(), Y = point[1].ToInt() };
                    } else {
                        formation.EndPosition = new Point() { X = point[0].ToInt(), Y = point[1].ToInt() };
                        rockFormations.Add(formation);
                        Line nextFormation = new Line();
                        nextFormation.StartPosition = formation.EndPosition;
                        formation = nextFormation;
                    }

                    if (formation.StartPosition.X < minX) { minX = formation.StartPosition.X; }
                    if (formation.StartPosition.X > maxX) { maxX = formation.StartPosition.X; }
                    if (formation.StartPosition.Y < minY) { minY = formation.StartPosition.Y; }
                    if (formation.StartPosition.Y > maxY) { maxY = formation.StartPosition.Y; }
                }
            }

            minX = 500 - minX < maxY + 2 - minY ? 500 - (maxY + 3 - minY) : minX;
            maxX = maxX - 500 < maxY + 2 - minY ? 500 + maxY + 3 - minY : maxX;
            maxY += 2;

            width = maxX - minX + 1;
            height = maxY - minY + 1;
            cave = new BlockType[width * height];

            for (int i = 0; i < rockFormations.Count; i++) {
                Line formation = rockFormations[i];
                if (formation.StartPosition.X > formation.EndPosition.X) {
                    Point temp = formation.EndPosition;
                    formation.EndPosition = formation.StartPosition;
                    formation.StartPosition = temp;
                } else if (formation.StartPosition.Y > formation.EndPosition.Y) {
                    Point temp = formation.EndPosition;
                    formation.EndPosition = formation.StartPosition;
                    formation.StartPosition = temp;
                }
            }

            AddRock(rockFormations);
        }

        [Description("How many units of sand come to rest before sand starts flowing into the abyss below?")]
        public override string SolvePart1() {
            return $"{FillSand()}";
        }

        [Description("How many units of sand come to rest?")]
        public override string SolvePart2() {
            for (int i = 0; i < cave.Length; i++) {
                BlockType block = cave[i];
                if (block == BlockType.Sand) { cave[i] = BlockType.Empty; }
            }
            List<Line> lines = new();
            lines.Add(new Line() { StartPosition = new Point() { X = minX, Y = minY + height - 1 }, EndPosition = new Point() { X = minX + width - 1, Y = minY + height - 1 } });
            AddRock(lines);
            return $"{FillSand()}";
        }

        private void AddRock(List<Line> lines) {
            for (int i = 0; i < lines.Count; i++) {
                Line line = lines[i];
                int index = line.StartPosition.X - minX + (line.StartPosition.Y - minY) * width;
                if (line.StartPosition.X == line.EndPosition.X) {
                    for (int j = line.StartPosition.Y; j <= line.EndPosition.Y; j++) {
                        cave[index] = BlockType.Rock;
                        index += width;
                    }
                } else {
                    for (int j = line.StartPosition.X; j <= line.EndPosition.X; j++) {
                        cave[index++] = BlockType.Rock;
                    }
                }
            }
        }
        private int FillSand() {
            int totalSand = 0;
            Queue<Sand> sand = new();
            sand.Enqueue(new Sand() { Position = 500 - minX });

            while (sand.Count > 0) {
                Sand current = sand.Dequeue();
                Sand next = new Sand() { Position = current.Position + width, Parent = current };
                if (next.Position >= cave.Length) { continue; }

                BlockType block = cave[next.Position];
                if (block == BlockType.Empty) {
                    sand.Enqueue(next);
                    continue;
                }

                if (cave[next.Position - 1] == BlockType.Empty) {
                    next.Position--;
                    sand.Enqueue(next);
                } else if (cave[next.Position + 1] == BlockType.Empty) {
                    next.Position++;
                    sand.Enqueue(next);
                } else {
                    cave[current.Position] = BlockType.Sand;
                    if (current.Parent != null) {
                        sand.Enqueue(current.Parent);
                    }
                    totalSand++;
                    //Display(current.Position);
                }
            }
            //Display(position);
            return totalSand;
        }
        private void Display(int position) {
            Console.WriteLine();
            for (int i = 0; i < cave.Length; i++) {
                BlockType block = cave[i];
                if (i == position) {
                    Console.Write('*');
                } else {
                    Console.Write(block == BlockType.Sand ? 'O' : block == BlockType.Rock ? '#' : '.');
                }
                if (((i + 1) % width) == 0) {
                    Console.WriteLine();
                }
            }
        }
        private enum BlockType : byte {
            Empty,
            Sand,
            Rock
        }
        private class Sand {
            public int Position;
            public Sand Parent;
            public override string ToString() {
                return $"{Position}";
            }
        }
    }
}
```

The syntax isn't bad, and the code makes a lot of sense. The docs for [Queue](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1?view=net-7.0) have plenty of examples.

I don't know if I'd choose this as my first language when building a new project, but I do understand why it's in the top 5 programming languages by popularity.

TODO: Run locally.

_[Part 1 Solution in JS](https://github.com/mager/aoc/blob/main/2022/14/js/part1.js) | [Part 2 Solution in JS](https://github.com/mager/aoc/blob/main/2022/14/js/part2.js)_

## [Day 15](https://adventofcode.com/2022/day/15): C++

Now that we've done C#, why not C++? Here's a simple solution from [@benanil](https://github.com/benanil/AdventOfCode2022/blob/main/SolutionsAfterDay12.cpp):

```cpp
namespace std {
	template <> struct hash<Vector2i> {
		unsigned long long operator()(const Vector2i& vec) const {
			return unsigned long long(vec.x) | (unsigned long long(vec.y) << 32ull);
		}
	};
}

template<typename T>
inline int ManhattanDistance(Vector2<T> a, Vector2<T> b)
{
	return abs(a.x - b.x) + abs(a.y - b.y);
}

int Day15()
{
	FILE* file = fopen("Assets/AOC15.txt", "r");
	
	char line[120];
	std::unordered_map<Vector2i, int> sensors;
	std::unordered_set<int> beaconYs;
	Vector2i boundsMin = INT_MAX, boundsMax = INT_MIN;

	while (fgets(line, sizeof(line), file))
	{
		const char* curr = line;
		
		Vector2i sensorPos = ParseVector<Vector2i>(curr);
		Vector2i beaconPos = ParseVector<Vector2i>(curr);
		Vector2i distance  = Vector2i(abs(sensorPos.x - beaconPos.x), abs(sensorPos.y - beaconPos.y)); // ManhattanDistance
		sensors[sensorPos] = distance.x + distance.y;
		beaconYs.insert(beaconPos.y);
		boundsMin = MinT(boundsMin, beaconPos - distance);
		boundsMax = MaxT(boundsMax, beaconPos + distance);
	}

	int result = 0;
	for (int j = boundsMin.x; j <= boundsMax.x; ++j)
	{
		Vector2i position = Vector2i(j, 2'000'000);
		
		for (auto const& [pos, dist] : sensors)
		{
			if (ManhattanDistance(pos, position) <= dist) { result++; break; }
		}
	}

	for (auto const& y: beaconYs) 
	{
		if (y == 2'000'000) { result--; }
	}

	printf("result: %d", result);
	return 0;
}
```

Nice use of [fgets](https://cplusplus.com/reference/cstdio/fgets/) to stream in the input. I was interested to see the naming convention of ["templates" for functions](https://cplusplus.com/doc/oldtutorial/templates/).

TODO: Run locally.

_[Part 1 Solution in JS](https://github.com/mager/aoc/blob/main/2022/15/js/part1.js) | [Part 2 Solution in JS](https://github.com/mager/aoc/blob/main/2022/15/js/part2.js)_

## [Day 16](https://adventofcode.com/2022/day/16): C3

Wait, another C variant? Why not?

```c
module day16;
import std::io;
import std::math;
import std::map;
import std::array::list;

define ValveMap = HashMap<char[], int>;
define IntPairList = List<int[<2>]>;
ValveMap v;

struct Valve
{
	int id;
	char[] name;
	int rate;
	int[10] tunnels;
	int tunnel_count;
	int[100] tunnel_cost;
	IntPairList list;
}

fn void populate_tunnels(Valve[] valves, int i, Valve* v, int tunnel, int cost)
{
	if (tunnel == i) return;
	int current_cost = v.tunnel_cost[tunnel];
	if (current_cost && current_cost <= cost) return;
	v.tunnel_cost[tunnel] = cost;
	Valve* other_valve = &valves[tunnel];
	for (int j = 0; j < other_valve.tunnel_count; j++)
	{
		populate_tunnels(valves, i, v, other_valve.tunnels[j], cost + 1);
	}
}

fn Valve[] load_valves(Valve[100]* available_slots)
{
	File f;
	f.open("valves.txt", "rb")!!;
	defer catch(f.close());
	int count = 0;
	while (!f.eof())
	{
		@pool()
		{
			char[] line = f.tgetline();
			char[][] parts = str::tsplit(line, " ");
			char[] name = str::copy(parts[1]);
			char[] rate_part = parts[4];
			int val = v.@get_or_set(name, (int)v.count);
			Valve *valve_entry = &(*available_slots)[val];
			assert(valve_entry.id == 0);
			count++;
			int rate = str::to_int(rate_part[5..^2])!!;
			int len = parts.len;
			*valve_entry = { .rate = rate, .id = val, .name = name };
			for (int i = 9; i < parts.len; i++)
			{
				char[] valve = parts[i];
				if (i < parts.len - 1)
				{
					valve = valve[..^2];
				}
				val = v.@get_or_set(str::copy(valve), (int)v.count);
				valve_entry.tunnels[valve_entry.tunnel_count++] = val;
			}
       };
    }
    Valve[] valves = (*available_slots)[:count];
    foreach (int i, &v : valves)
    {
        for (int j = 0; j < v.tunnel_count; j++)
        {
            populate_tunnels(valves, i, v, v.tunnels[j], 1);
        }
    }
    // Make entering the other tunnels super expensive.
    foreach (int i, &v : valves)
    {
        if (!v.rate) continue;
        foreach (&v2 : valves)
        {
            v2.list.append({ i, v2.tunnel_cost[i] });
        }
    }
    assert(count == v.count);
    return valves;
}

fn int visit_valve(int id, Valve[] valves, int* locations, int minutes, int current_flow)
{
	assert(minutes > 0);
	Valve* current = &valves[id];
	assert(locations[id] == 1);
	int total = 0;
	if (current.rate)
	{
		minutes--;
		total += current_flow;
		current_flow += current.rate;
	}
	int best_val = minutes * current_flow;
	if (minutes > 1)
	{
		foreach (pair : current.list)
		{
			int i = pair[0];
			if (locations[i]) continue;
			int cost = pair[1];
			assert(cost);
			if (cost >= minutes) continue;
			locations[i] = 1;
			int val = current_flow * cost + visit_valve(i, valves, locations, minutes - cost, current_flow);
			locations[i] = 0;
			if (val > best_val) best_val = val;
		}
	}
	return best_val + total;
}

fn int visit_valve2(int id, Valve[] valves, int* locations, int minutes, int current_flow, int start_moves, int start)
{
	assert(minutes > 0);
	Valve* current = &valves[id];
	int total = 0;
	if (current.rate)
	{
		minutes--;
		total += current_flow;
		current_flow += current.rate;
	}
	int best_val = minutes * current_flow + visit_valve(start, valves, locations, start_moves, 0);
	if (minutes > 1)
	{
		foreach (pair : current.list)
		{
			int i = pair[0];
			if (locations[i]) continue;
			int cost = pair[1];
			assert(cost);
			if (cost >= minutes) continue;
			locations[i] = 1;
			int val = current_flow * cost + visit_valve2(i, valves, locations, minutes - cost, current_flow, start_moves, start);
			locations[i] = 0;
			if (val > best_val)
			{
				best_val = val;
			}
		}
	}
	return best_val + total;
}

fn void part1(Valve[] valves, int start)
{
	int[100] locations;
	locations[start] = 1;
	int flow = visit_valve(start, valves, &locations, 30, 0);
	io::printfln("Best flow: %d", flow);
}

fn void part2(Valve[] valves, int start)
{
	int[100] locations;
	locations[start] = 1;
	int flow = visit_valve2(start, valves, &locations, 26, 0, 26, start);
	io::printfln("Best flow: %d", flow);
}

fn void main()
{
	v.init();
	int start = -1;
	Valve[] valves = load_valves(&&Valve[100] {});
	foreach (int i, valve : valves)
	{
		if (valve.name == "AA") start = i;
	}
	part1(valves, start);
	part2(valves, start);
}
```

This looks really nice. I like the syntax of this variant the most; it's very readable. I was surprised to see `assert` calls in the function; I wonder what the error message would be if one of those failed? [The docs](https://c3-lang.org/) are pretty good too.

Shoutout to [@lerno for the solution](https://github.com/lerno/aoc_2022_c3/blob/main/day16.c3).

TODO: Run locally.

## Day 17

## Day 18

# Conclusion

TODO
