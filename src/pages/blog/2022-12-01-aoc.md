---
layout: "../../layouts/BlogPost.astro"
title: "Learning 31 programming languages in 31 days with Advent of Code"
pubDate: "2022-12-01"
updatedDate: "2022-12-10"
description: "Instead of just using a single language, I wanted to solve the puzzle in a language I know, then lurk the internet for the solution in another language each day."
tags: ["Code"]
---

_This post is still a work in progress, please excuse the incompleteness._

The excitement of waking up every morning with a new puzzle to solve is one of the many reasons I love December. I've never actually completed [Advent of Code](https://adventofcode.com), a daily advent calendar-style programming challenge created by [@ericwastl](https://twitter.com/ericwastl), but I think this is my year.

I've made attempts in the past, but usually gave up because it was too hard, or I didn't have time to go all the way through 31 different challenges. But this year, I figured out a way to make it easier, and I decided to learn 31 new programming languages in the process.

Jump to day:

* [Day 1 - Javascript](#day-1-javascript)
* [Day 2 - Rust](#day-2-rust)
* [Day 3 - Crystal](#day-3-crystal)
* [Day 4 - Elm](#day-4-elm)
* [Day 5 - Java](#day-5-java)
* [Day 6 - Excel](#day-6-excel)


## [Day 1](https://adventofcode.com/2022/day/1): Javascript

My original plan was to complete all of the challenges in Golang first, and then I was going to attempt to learn Rust and do each challenge in Rust. This turned out to be a lot more work than I thought; it took significantly more code to solve the challenges in Golang & Rust and I wanted to have success faster.

I needed to start with a language that I felt comfortable with and had a lot of experience with. Enter our trusty, old friend from long ago: Javascript.

I started the challenge a few days late (December 3rd), so I wanted to lurk on Github and see how others were solving the puzzles. Some would call this cheating; I call it learning. I had an ephiphany when I was saw how simple [@colourgarden's JS solution for Day 1](https://github.com/colourgarden/advent-of-code/blob/main/2022/day1/index.js) was:

```js
const path = require('path');
const fs = require('fs');

// Get input data of groups of numbers separated by blank lines.
const data = fs.readFileSync(`./input.txt`, 'utf-8');

// Convert the individual lines of each group to Numbers and tally.
const elves = data.split('\n\n').map(group => {
  return group
    .split('\n')
    .map(group => Number(group))
    .reduce((total, calories) => total + calories);
});

// Find the biggest number in the resultant array.
const most = Math.max(...elves);

// Get the index of the biggest number.
const who = elves.indexOf(most);

// Print answer to part one.
console.log(`Elf ${who} is carrying the most calories. They are carrying ${most} calories.`);
```

This code is concise, well-commented, and super easy to understand. I ran it locally with `node 01/main.js` and got the answer for part 1. Their solution for part 2 was just as simple:

```js
// Sort values by descending.
const sorted = [...elves].sort((a, b) => b - a);

// Get three biggest numbers and tally.
const topThree = sorted.slice(0, 3).reduce((total, calories) => total + calories);

// Print answer to part two.
console.log(topThree);
```

I peeked at their solution for day 2 and did the same thing. He hadn't started the challenge for day 3 yet but I was determined to solve it. With a little help from [Github Copilot](https://github.com/features/copilot), I was able to solve day 3 in just a few minutes.

**I had my new plan: each day, complete all of the challenges in Javascript first, then try to complete the challenge in a new language I'm not familiar with.**

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/01/js/main.js)_

## [Day 2](https://adventofcode.com/2022/day/2): Rust

Whenever I learn a new language, I immediately visit https://learnxinyminutes.com. I love this site because it gives you a quick overview of the syntax of a language, with tons of comments and example code. I skimmed the Rust page there and also discovered this useful, step-by-step resource for [getting started with Rust](https://stepik.org/lesson/9268/step/1).

One of the challenges of learning all these new languages is that I'll have to install the build tools locally and get familiar with the developer experience.

Luckily, installing Rust & Cargo (Rust's package manager) is a one-liner:

```sh
curl https://sh.rustup.rs -sSf | sh
```

When I initially attempted the challenge in Rust, I set out to find some solutions from skilled Rust developers on Github. Luckily, I found [this awesome repo](https://github.com/Bogdanp/awesome-advent-of-code) with AOC solutions in many languages (wow, someone did it in [Excel](https://github.com/askholme/advent-of-code)). I jumped to the Rust section and tried to find a good example. 

I discovered ZAZPRO's [AOC repo](https://github.com/ZAZPRO/adventofcode-2022) and noticed a `00` folder with a Hello World script. I cloned the repo, and ran it locally with `cargo run --bin part_one`:

```sh
➜ cargo run --bin part_one
   Compiling rust v0.1.0 (/Users/mager/Code/adventofcode-2022/00/rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.90s
     Running `target/debug/part_one`
Hello, world!
```

Easy enough. Next, I wanted to copy their solution locally and try to run it. In my `02` folder, I ran `cargo new rust` which created a few new files:

```sh
├── Cargo.toml
└── src
    └── main.rs
```

I followed @ZAZPRO's lead and created a `bin` folder in `src` and added the code to `part_one.rs` and ran it locally:

```sh
➜ cargo run --bin part_one
   Compiling rust v0.1.0 (/Users/mager/Code/aoc/2022/02/rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.82s
     Running `target/debug/part_one`
Final Score: 8392
```

It works! Now, let's check out the solution for part 1 in Rust:

```rs
use std::error::Error;

// Enum that describes match result.
enum Outcome {
    Win,
    Draw,
    Lose,
}

// Trait for outcome to calculate result score.
impl Outcome {
    pub fn get_score(&self) -> u32 {
        match &self {
            Outcome::Win => 6,
            Outcome::Draw => 3,
            Outcome::Lose => 0,
        }
    }
}

// Possible Items that players can throw.
enum Item {
    Rock,
    Paper,
    Scissors,
}

// Value of each Item.
impl Item {
    pub fn get_score(&self) -> u32 {
        match &self {
            Item::Rock => 1,
            Item::Paper => 2,
            Item::Scissors => 3,
        }
    }
}

// Struct that holds each game Round.
struct Round {
    opponent: Item,
    player: Item,
}

impl Round {
    // Common Rust way to create structs.
    pub fn new(opponent: Item, player: Item) -> Self {
        Self { opponent, player }
    }

    // Calculate outcome of the Round.
    pub fn get_outcome(&self) -> Outcome {
        match (&self.player, &self.opponent) {
            (Item::Rock, Item::Scissors) => Outcome::Win,
            (Item::Rock, Item::Paper) => Outcome::Lose,
            (Item::Paper, Item::Rock) => Outcome::Win,
            (Item::Paper, Item::Scissors) => Outcome::Lose,
            (Item::Scissors, Item::Paper) => Outcome::Win,
            (Item::Scissors, Item::Rock) => Outcome::Lose,
            _ => Outcome::Draw,
        }
    }

    // Calculate score of the round.
    pub fn calc_score(&self) -> u32 {
        &self.player.get_score() + &self.get_outcome().get_score()
    }
}

// Program entry point.
fn main() -> Result<(), Box<dyn Error>> {
    // List of game rounds.
    let mut rounds: Vec<Round> = Vec::new();

    // Read input file into String.
    let file = std::fs::read_to_string("../input.txt")?;
    // For each line in the file.
    for line in file.lines() {
        // Split a line in two values.
        let mut iter = line.split_whitespace();

        // First value is what current opponent is throwing.
        let current_opponent = match iter.next() {
            Some(v) => match v {
                "A" => Item::Rock,
                "B" => Item::Paper,
                "C" => Item::Scissors,
                _ => todo!(),
            },
            None => todo!(),
        };

        // Second value is what current player is throwing.
        let current_player = match iter.next() {
            Some(v) => match v {
                "X" => Item::Rock,
                "Y" => Item::Paper,
                "Z" => Item::Scissors,
                _ => todo!(),
            },
            None => todo!(),
        };

        // Create a new Round struct with opponent and player values.
        rounds.push(Round::new(current_opponent, current_player));
    }

    // Calculate a final sum by calling a score calculation method of Round struct and summing those up.
    let final_sum: u32 = rounds.into_iter().map(|r| r.calc_score()).sum();
    println!("Final Score: {final_sum}");

    Ok(())
}
```

It's a lot of code, but it makes sense. At first glance it reminds me of Ruby or Elixir, but more elegant. I'd like to play around more with Rust, but there's no time; I need to learn another new language.

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/02/js/main.js)_

## [Day 3](https://adventofcode.com/2022/day/3): Crystal

I heard about this one briefly on Hacker News a while back and always wanted to use it. While `brew install crystal` ran, I determined that Crystal is like a mix between Ruby and C. From their [Github README](https://github.com/crystal-lang/crystal):

> We love Ruby's efficiency for writing code. We love C's efficiency for running code. We want the best of both worlds.

Let's take a look at the solution for day 1 before we try to run it:

```rb
puts STDIN.each_line.reduce(0) { |acc, line|
  s = line.size() // 2
  a,b = line[0..s-1],line[s..]
  common = (a.chars.to_set & b.chars.to_set).to_a[0]
  priority = common.ord - (common.uppercase? ? 38 : 'a'.ord - 1)
  acc + priority
}
```

I love how simple this is, way less code than my JS implementation. Shoutout to [@DestyNova](https://github.com/DestyNova/advent_of_code_2022/tree/main/3) on the solution & detailed blog post about the experience (and how he used ChatGPT to find a solution in Python).

Getting this running locally was pretty easy as well:

```sh
➜  crystal git:(main) ✗ cat ../input.txt | crystal run part1.cr
... Lots of "ld: warning: object file (somefile.o) was built for newer macOS version than being linked" warnings ...
7785
```

Here's part 2:

```rb
puts STDIN.each_line.to_a.in_groups_of(3, "").reduce(0) { |acc,lines|
  common = lines.map {|s| s.chars.to_set}.reduce {|a,s| a & s}.to_a[0]
  priority = common.ord - (common.uppercase? ? 38 : 'a'.ord - 1)
  acc + priority
}
```

Crystal looks fun and I want to spend more time with it. Fun fact: The last time I worked on anything that resembled Ruby was one of my first hack day projects (almost 10 years ago!): [Sendwiki](https://github.com/mager/sendwiki/blob/master/main.rb).

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/03/js/main.js)_

## [Day 4](https://adventofcode.com/2022/day/4): Elm

I've seen Elm before on Hacker News, but never double clicked further. A quick glance at [Learn X](https://learnxinyminutes.com/docs/elm/), and the syntax looks... pretty? No brackets, pipe functions, indenting matters, support for pattern matching. I approve. It only took a few seconds to install, and they even suggested a [tutorial](https://guide.elm-lang.org/) to get started.

Let's check out [@ostcar](https://github.com/ostcar/aoc2022)'s solution:

```elm
module Days.Day4 exposing (solution, testSolution1, testSolution2)

import Expect exposing (equal)
import Parser exposing ((|.), (|=), int, symbol)
import Test exposing (Test, test)


solution : ( () -> String, () -> String )
solution =
    ( \_ -> solution1 puzzleInput
    , \_ -> solution2 puzzleInput
    )


solution1 : String -> String
solution1 =
    String.lines
        >> List.filter (String.isEmpty >> not)
        >> List.map parseLine
        >> countFunc isFullIntersect
        >> String.fromInt


parseLine : String -> ( ( Int, Int ), ( Int, Int ) )
parseLine input =
    let
        inputParser =
            Parser.succeed (\a b c d -> ( ( a, b ), ( c, d ) ))
                |= int
                |. symbol "-"
                |= int
                |. symbol ","
                |= int
                |. symbol "-"
                |= int
    in
    Parser.run inputParser input
        |> Result.withDefault ( ( 0, 0 ), ( 0, 0 ) )


isFullIntersect : ( ( Int, Int ), ( Int, Int ) ) -> Bool
isFullIntersect ( first, second ) =
    let
        firstIsFullIntersect ( a, b ) ( c, d ) =
            a >= c && b <= d
    in
    firstIsFullIntersect first second || firstIsFullIntersect second first


countFunc : (a -> Bool) -> List a -> Int
countFunc func list =
    List.foldl
        (\e count ->
            if func e then
                count + 1

            else
                count
        )
        0
        list


testSolution1 : Test
testSolution1 =
    test "test input1" <|
        \_ -> equal (solution1 testInput) "2"


solution2 : String -> String
solution2 =
    String.lines
        >> List.filter (String.isEmpty >> not)
        >> List.map parseLine
        >> countFunc isPartlyIntersect
        >> String.fromInt


isPartlyIntersect : ( ( Int, Int ), ( Int, Int ) ) -> Bool
isPartlyIntersect ( first, second ) =
    let
        firstInSecond ( a, b ) ( c, d ) =
            a <= c && b >= c
    in
    firstInSecond first second || firstInSecond second first


testSolution2 : Test
testSolution2 =
    test "test input2" <|
        \_ -> equal (solution2 testInput) "4"


testInput : String
testInput =
    """
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8"""


puzzleInput : String
puzzleInput =
    """
75-76,18-75
2-54,1-50
82-83,78-82
...
"""
```

Definitely some weird syntax going on in there, but the code is readable and it makes sense. I was surpsied you could import these parser operators like `|.` and `|=` (great docs on the [Parser](https://package.elm-lang.org/packages/elm/parser/latest/) by the way).

I was really curious to get this up and running, and it turns out that @ostcar built a website along with the code. 

```
➜  elm make src/Main.elm
Starting downloads...
Dependencies ready!
Success! Compiled 8 modules.

    Main ───> index.html
```

The web page shows a list of days and a link to their solution. Here's the [source](https://github.com/ostcar/aoc2022/blob/main/src/Main.elm) if you're interested.

Elm looks pretty powerful. I also starred [this repo from @rtfeldman](https://github.com/rtfeldman/elm-spa-example) for later to learn how to build a single page application using Elm.

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/04/js/main.js)_

## [Day 5](https://adventofcode.com/2022/day/5): Java

While I haven't actually built anything myself in Java, I've been familiar with it for a while and been exposed to it in code reviews and interviews a bunch. I hope to play with Kotlin before Xmas.

I found an elegant solution (with tests!) from [@vuryss](https://github.com/vuryss/aoc-java/blob/master/src/main/java/com/vuryss/aoc/solutions/event2022/Day5.java):

```java
package com.vuryss.aoc.solutions.event2022;

import com.vuryss.aoc.DayInterface;

import java.util.*;

public class Day5 implements DayInterface {
    @Override
    public Map<String, String> part1Tests() {
        return Map.of(
            """
                [D]    
            [N] [C]    
            [Z] [M] [P]
             1   2   3
            
            move 1 from 2 to 1
            move 3 from 1 to 3
            move 2 from 2 to 1
            move 1 from 1 to 2
            """,
            "CMZ"
        );
    }

    @Override
    public Map<String, String> part2Tests() {
        return Map.of(
            """
                [D]    
            [N] [C]    
            [Z] [M] [P]
             1   2   3
            
            move 1 from 2 to 1
            move 3 from 1 to 3
            move 2 from 2 to 1
            move 1 from 1 to 2
            """,
            "MCD"
        );
    }

    @Override
    public String part1Solution(String input) {
        var parts = input.split("\n\n");
        var stacks = createCurrentState(parts[0]);

        for (var line: parts[1].split("\n")) {
            var moveParts = line.trim().split(" ");
            var originStack = stacks.get(Integer.parseInt(moveParts[3]));
            var targetStack = stacks.get(Integer.parseInt(moveParts[5]));

            for (var i = 0; i < Integer.parseInt(moveParts[1]); i++) {
                targetStack.addFirst(originStack.pollFirst());
            }
        }

        return getTopCrates(stacks);
    }

    @Override
    public String part2Solution(String input) {
        var parts = input.split("\n\n");
        var stacks = createCurrentState(parts[0]);

        for (var line: parts[1].split("\n")) {
            var moveParts = line.trim().split(" ");
            var originStack = stacks.get(Integer.parseInt(moveParts[3]));
            var targetStack = stacks.get(Integer.parseInt(moveParts[5]));
            var tempList = new LinkedList<Character>();

            for (var i = 0; i < Integer.parseInt(moveParts[1]); i++) {
                tempList.add(originStack.pollFirst());
            }

            while (!tempList.isEmpty()) {
                targetStack.addFirst(tempList.pollLast());
            }
        }

        return getTopCrates(stacks);
    }

    private HashMap<Integer, LinkedList<Character>> createCurrentState(String state) {
        var stacks = new HashMap<Integer, LinkedList<Character>>();

        for (var line: state.split("\n")) {
            var charIndex = 1;
            var stackId = 1;

            while (line.length() > charIndex) {
                var c = line.charAt(charIndex);
                var stack = stacks.getOrDefault(stackId, new LinkedList<>());
                stacks.putIfAbsent(stackId, stack);

                if (c >= 'A' && c <= 'Z') {
                    stack.add(c);
                }

                charIndex += 4;
                stackId++;
            }
        }

        return stacks;
    }

    private String getTopCrates(HashMap<Integer, LinkedList<Character>> stacks) {
        StringBuilder result = new StringBuilder();

        for (var entry: stacks.entrySet()) {
            result.append(entry.getValue().peek());
        }

        return result.toString();
    }
}
```

This puzzle was trickier because you had to do more work to parse the input:

```
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 
```

We have to strip out the spaces and `[]` characters and rotate it so we can work with the stacks better. We need something like: `[[Z, N], [M, C, D], [P]]`.

In Javascript, we can use a helper transpose function and pipe some map and filter functions:


```js
Array.prototype.transpose = function () {
    return this[0].map((_, i) => this.map((y) => y[i]));
};

const stacks = input_stacks
    .map((row) => [...row])
    .transpose()
    .map((row) => row.join("").replace(/\[|\]/g, "").trim())
    .filter((row) => row !== "")
    .map((row) => [...row.slice(0, -1)].reverse());
```

In Java, we iterate through each character and check if it's a letter and add it to a `LinkedList`:

```java
private HashMap<Integer, LinkedList<Character>> createCurrentState(String state) {
    var stacks = new HashMap<Integer, LinkedList<Character>>();

    for (var line: state.split("\n")) {
        var charIndex = 1;
        var stackId = 1;

        while (line.length() > charIndex) {
            var c = line.charAt(charIndex);
            var stack = stacks.getOrDefault(stackId, new LinkedList<>());
            stacks.putIfAbsent(stackId, stack);

            if (c >= 'A' && c <= 'Z') {
                stack.add(c);
            }

            charIndex += 4;
            stackId++;
        }
    }

    return stacks;
}
```

The docs for [HashMap](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html) are detailed, and function names like `getOrDefault` and `putIfAbsent` are clear and intuitive.

Let's see how easy it is to get running locally. One reason I chose `@vuryss`'s solution is because his README had instructions on how to run it and included a straightforward command for running a specific day's solution: `./gradlew bootRun --args="--day=1"`.

It's as easy as running `brew install java` to get Java installed these days (previously you had to download an executable and install the JVM separately). While I waited, I asked [ChatGPT](https://chat.openai.com/chat) why Java is so popular:

![Java is a popular programming language because it is versatile and easy to learn. It is widely used for building a variety of applications, including web, mobile, and desktop applications. Additionally, Java has a large and active community of developers, which makes it easy to find support and assistance when needed. Because of its popularity, there is a wealth of documentation and learning resources available, making it a good choice for people who are new to programming.](/images/blog/2022-12-01-aoc.md/day-5-1.png)

So, I actually had trouble running this locally, but I'll circle back later and try again when I have more time.

I'm a few days behind so, on to the next one!

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/05/js/main.js)_

## [Day 6](https://adventofcode.com/2022/day/6): Excel

That's right, you didn't misread. We're going to solve this one with Excel. While Microsoft's spreadsheet app isn't technically considered a programming language, it's been used for decades for manipulating data, and its table-first, dependable interface seems like a perfect tool for this challenge. In fact, the underlying programming language that is used in that little input box above the table is [VBA](https://learn.microsoft.com/en-us/office/vba/api/overview/language-reference), which is a dialect of Visual Basic.

Luckily someone was brave enough to try these challenges in Excel ([shoutout @askholme](https://github.com/askholme/advent-of-code/blob/main/2022/Day%206.xlsx)). I downloaded the `xlsx` file and uploaded it to Google Drive.

![AOC Day 6 using spreadsheets](/images/blog/2022-12-01-aoc.md/day-6-1.png)

In cell A1, we have the 4000 plus-character string. And then in each row below, we grab a 14-character chunk using the [MID function](https://support.google.com/docs/answer/3094129?hl=en) which lets you select a substring given a starting point and character length. Columns C-P is a single character, and then in column Q, we're using a combination of COUNTA and UNIQUE to determine if the first four characters are all unique. So the first row looks like this:

```
=COUNTA(UNIQUE(C4:F4,1,TRUE))=4
```

Then you can filter for TRUE and the first row returned is the answer. 

![AOC Day 6 using spreadsheets](/images/blog/2022-12-01-aoc.md/day-6-2.png)

Column R is the same thing for part 2 (14 characters instead of 4). Pretty clever, I must say. I'm going to lurk on this repo to see how other days are solved.

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/06/js/main.js)_

## Day 7

## Day 8

## Day 9

## Day 10

# Conclusion

TODO
