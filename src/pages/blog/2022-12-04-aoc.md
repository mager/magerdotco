---
layout: "../../layouts/BlogPost.astro"
title: "DRAFT: Learning 31 programming languages in 31 days with Advent of Code"
pubDate: "2022-12-01"
updatedDate: "2022-12-04"
description: "Instead of just using a single language, I wanted to solve the puzzle in a language I know, then lurk the internet for the solution in another language."
tags: ["Code"]
---

_This post is still a work in progress, please excuse the incompleteness._

The excitement of waking up every morning with a new puzzle to solve is one of the many reasons I love December. I've never actually completed [Advent of Code](https://adventofcode.com), a daily advent calendar-style programming challenge created by [@ericwastl](https://twitter.com/ericwastl), but I think this is my year.

I've made attempts in the past, but usually gave up because it was too hard, or I didn't have time to go all the way through 31 different challenges. But this year, I figured out a way to make it easier, and I decided to learn 31 new programming languages in the process.

## [Day 1](https://adventofcode.com/2022/day/1): Javascript

My original plan was to actually complete all of the challenges in Golang first, and then I was going to attempt to learn Rust and do each challenge in Rust. This turned out to be a lot more work than I thought; it tooks significantly more code to solve the challenges in Golang & Rust and I wanted to have success faster.

I needed to start with a language that I felt comfortable with and had a lot of experience with. Enter our trusty, old friend from long ago: Javascript.

I started the challenge a few days late (December 3rd), so I wanted to lurk on Github and see how others were solving the puzzles. Some would call this cheating; I call it learning. I had an ephiphany when I was saw how simple [@colourgarden's JS solution for Day 1](https://github.com/colourgarden/advent-of-code/blob/main/2022/day1/index.js) was:

```js
const path = require('path');
const fs = require('fs');

// Get input data of groups of numbers separated by blank lines.
const data = fs.readFileSync(`./input.txt`, 'utf-8');

// Convert the individual lines of each group to Numbers and tally.
const elves = data.split('\n\n').map(group => {
  return group
    .split('\n')
    .map(group => Number(group))
    .reduce((total, calories) => total + calories);
});

// Find the biggest number in the resultant array.
const most = Math.max(...elves);

// Get the index of the biggest number.
const who = elves.indexOf(most);

// Print answer to part one.
console.log(`Elf ${who} is carrying the most calories. They are carrying ${most} calories.`);
```

This code is concise, well-commented, and super easy to understand. I ran it locally with `node 01/main.js` and got the answer for part 1. Their solution for part 2 was just as simple:

```js
// Sort values by descending.
const sorted = [...elves].sort((a, b) => b - a);

// Get three biggest numbers and tally.
const topThree = sorted.slice(0, 3).reduce((total, calories) => total + calories);

// Print answer to part two.
console.log(topThree);
```

I peeked at their solution for day 2 and did the same thing. He hadn't started the challenge for day 3 yet but I was determined to solve it. With a little help from [Github Copilot](https://github.com/features/copilot), I was able to solve day 3 in just a few minutes.

**I had my new plan: each day, complete all of the challenges in Javascript first, then try to complete the challenge in a new language I'm not familiar with.**

_[Solution in JS](https://github.com/mager/aoc/blob/main/2022/01/js/main.js)_

## [Day 2](https://adventofcode.com/2022/day/2): Rust

Whenever I learn a new language, I immediately visit https://learnxinyminutes.com. I love this site because it gives you a quick overview of the syntax of a language, with tons of comments and example code. I skimmed the Rust page there and also discovered this useful, step-by-step resource for [getting started with Rust](https://stepik.org/lesson/9268/step/1).

One of the challenges of learning all these new languages is that I'll have to install the build tools locally and get familiar with the developer experience.

Luckily, installing Rust & Cargo (Rust's package manager) is a one-liner:

```sh
curl https://sh.rustup.rs -sSf | sh
```

When I initially attempted the challenge in Rust, I set out to find some solutions from skilled Rust developers on Github. Luckily, I found [this awesome repo](https://github.com/Bogdanp/awesome-advent-of-code) with AOC solutions in many languages. I jumped to the Rust section and tried to find a good example. 


I discovered ZAZPRO's [AOC repo](https://github.com/ZAZPRO/adventofcode-2022) and noticed a `00` folder with a Hello World script. I cloned the repo, and ran it locally with `cargo run --bin part_one`:

```sh
➜ cargo run --bin part_one
   Compiling rust v0.1.0 (/Users/mager/Code/adventofcode-2022/00/rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.90s
     Running `target/debug/part_one`
Hello, world!
```

Easy enough. Next, I wanted to copy their solution locally and try to run it. In my `02` folder, I ran `cargo new rust` which created a few new files:

```sh
├── Cargo.toml
└── src
    └── main.rs
```

I followed @ZAZPRO's lead and created a `bin` folder in `src` and added the code to `part_one.rs` and ran it locally:

```sh
➜ cargo run --bin part_one
   Compiling rust v0.1.0 (/Users/mager/Code/aoc/2022/02/rust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.82s
     Running `target/debug/part_one`
Final Score: 8392
```

It works! Now, let's check out the solution for part 1 in Rust:

```rs
use std::error::Error;

// Enum that describes match result.
enum Outcome {
    Win,
    Draw,
    Lose,
}

// Trait for outcome to calculate result score.
impl Outcome {
    pub fn get_score(&self) -> u32 {
        match &self {
            Outcome::Win => 6,
            Outcome::Draw => 3,
            Outcome::Lose => 0,
        }
    }
}

// Possible Items that players can throw.
enum Item {
    Rock,
    Paper,
    Scissors,
}

// Value of each Item.
impl Item {
    pub fn get_score(&self) -> u32 {
        match &self {
            Item::Rock => 1,
            Item::Paper => 2,
            Item::Scissors => 3,
        }
    }
}

// Struct that holds each game Round.
struct Round {
    opponent: Item,
    player: Item,
}

impl Round {
    // Common Rust way to create structs.
    pub fn new(opponent: Item, player: Item) -> Self {
        Self { opponent, player }
    }

    // Calculate outcome of the Round.
    pub fn get_outcome(&self) -> Outcome {
        match (&self.player, &self.opponent) {
            (Item::Rock, Item::Scissors) => Outcome::Win,
            (Item::Rock, Item::Paper) => Outcome::Lose,
            (Item::Paper, Item::Rock) => Outcome::Win,
            (Item::Paper, Item::Scissors) => Outcome::Lose,
            (Item::Scissors, Item::Paper) => Outcome::Win,
            (Item::Scissors, Item::Rock) => Outcome::Lose,
            _ => Outcome::Draw,
        }
    }

    // Calculate score of the round.
    pub fn calc_score(&self) -> u32 {
        &self.player.get_score() + &self.get_outcome().get_score()
    }
}

// Program entry point.
fn main() -> Result<(), Box<dyn Error>> {
    // List of game rounds.
    let mut rounds: Vec<Round> = Vec::new();

    // Read input file into String.
    let file = std::fs::read_to_string("../input.txt")?;
    // For each line in the file.
    for line in file.lines() {
        // Split a line in two values.
        let mut iter = line.split_whitespace();

        // First value is what current opponent is throwing.
        let current_opponent = match iter.next() {
            Some(v) => match v {
                "A" => Item::Rock,
                "B" => Item::Paper,
                "C" => Item::Scissors,
                _ => todo!(),
            },
            None => todo!(),
        };

        // Second value is what current player is throwing.
        let current_player = match iter.next() {
            Some(v) => match v {
                "X" => Item::Rock,
                "Y" => Item::Paper,
                "Z" => Item::Scissors,
                _ => todo!(),
            },
            None => todo!(),
        };

        // Create a new Round struct with opponent and player values.
        rounds.push(Round::new(current_opponent, current_player));
    }

    // Calculate a final sum by calling a score calculation method of Round struct and summing those up.
    let final_sum: u32 = rounds.into_iter().map(|r| r.calc_score()).sum();
    println!("Final Score: {final_sum}");

    Ok(())
}
```

_MORE COMING SOON!_


# Conclusion

TODO